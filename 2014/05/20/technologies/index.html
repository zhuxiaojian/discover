<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
<title>前端开发技术的发展 | 发现前端</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="og:type" content="blog">
<meta name="og:title" content="前端开发技术的发展">
<meta name="og:url" content="http://ppanda.com/discover/2014/05/20/technologies/">
<meta name="og:image" content="http://ww3.sinaimg.cn/large/005yyi5Jjw1egkik3qdd4j30ji1al0yz.jpg">
<meta name="og:site_name" content="发现前端">
<meta name="og:description" content="前端开发技术的发展
前端开发技术，从狭义的定义来看，是指围绕HTML、JavaScript、CSS这样一套体系的开发技术，它的运行宿主是浏览器。从广义的定义来看，包括了：

专门为手持终端设计的类似WML这样的类HTML语言，类似WMLScript这样的类JavaScript语言。
VML和SVG等基于XML的描述图形的语言。
从属于XML体系的XML，XPath，DTD等技术。
用于支撑后端的A">
<meta name="twitter:card" content="summary">
  
<link rel="alternative" href="/atom.xml" title="发现前端" type="application/atom+xml">
  
  
<link rel="icon" href="/discover/favicon.ico">
  
  <link href="http://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/discover/css/style.css" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>
<body>
    <header id="header">
  <div class="header-outer outer">
    <div class="header-title inner">
      <h1 class="logo-wrap">
        <a href="/discover/" class="logo">发现前端</a>
      </h1>
      
    </div>
    <div class="header-inner inner">
      <nav class="main-nav">
        
          <a class="main-nav-link" href="/discover/">Home</a>
        
          <a class="main-nav-link" href="/discover/about">about</a>
        
        <a class="main-nav-link" title="尚未完全开放" href="#">#我发现</a>
      </nav>
    </div>
  </div>
</header>
    <div class="pure-g-r">
      <aside class="pure-u-1-6">
        <div class="widget-wrap">
    <h3 class="widget-title">技术站点</h3>
    <div class="widget">
      <ul class="category-list category-list-side">
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://tid.tenpay.com/'>财付通设计中心 UID</a></li>
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://cdc.tencent.com/'>腾讯用户研究与体验设计中心 CDC</a></li>
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://www.alloyteam.com/'>腾讯Web前端 Alloy 团队 Blog</a></li>
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://gdc.qq.com/'>QQ游戏设计中心GDC</a></li>
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://mxd.tencent.com/'>腾讯移动互联网设计团队MXD</a></li>
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://ecd.tencent.com/'>腾讯电商用户设计体验部ECD</a></li>
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://isux.tencent.com/'>腾讯社交用户体验设计部ISUX</a></li>
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://djt.qq.com/'>腾讯大讲堂</a></li>
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://www.aliued.cn/'>阿里巴巴用户体验设计部UED</a></li>
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://ued.taobao.com/blog/'>淘宝网UED官方博客</a></li>
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://www.aliued.com/'>阿里巴巴国际站UED团队</a></li>
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://ux.etao.com/'>淘宝一淘用户体验中心UX</a></li>
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://www.searchtb.com/'>淘宝搜索技术博客</a></li>
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://alipaymiddleware.com/'>支付宝中间件团队</a></li>
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://ued.tmall.com/'>天猫UED</a></li>
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://www.baiduux.com/'>百度泛用户体验部UUX</a></li>
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://mux.baidu.com/'>百度无线用户体验部MUX</a></li>
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://ued.baidu.com/'>百度商业用户体验部UED</a></li>
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://mued.sohu.com/'>搜狐移动用户体验团队MUED</a></li>
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://ued.focus.cn/'>搜狐焦点用户体验设计UED</a></li>
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://udc.weibo.com/'>新浪微博用户体验设计中心UDC</a></li>
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://ued.sina.com/'>新浪UED</a></li>
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://www.75team.com/'>奇虎360公司Web前端</a></li>
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://uxc.360.cn/'>360UXC用户体验设计中心</a></li>
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://ued.ctrip.com/blog/'>携程旅行前端开发团队UED</a></li>
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://fed.renren.com/'>人人网FED</a></li>
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://ued.sogou.com/'>搜狗设计团队UED博客</a></li>
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://uedc.163.com/'>网易用户体验设计中心UEDC</a></li>
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://cued.xunlei.com/'>迅雷用户体验设计中心CUED</a></li>
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://blog.19ued.com/'>19楼UED</a></li>
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://ued.5173.com/'>5173用户体验设计团队</a></li>
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://ued.iciba.com/'>爱词霸UED团队 </a></li>
    <li class="category-list-item"><a target="_blank" class="category-list-link" href='http://ued.ctrip.com/blog/wp-content/webkitcss/index.html'>Webkit css</a></li>
  </ul>

    </div>
  </div>
      </aside>
      <section class="pure-u-2-3"><article id="post-technologies" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      前端开发技术的发展
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/discover/2014/05/20/technologies/" class="article-date">
  <time datetime="2014-05-20T12:22:43.000Z" itemprop="datePublished">2014年5月20日</time>
</a>
      
  <div class="article-category">
    
	    <a class="pure-button" style='display:inline;' href="/discover/categories/前端心得/">前端心得</a>
	  
  </div>

      <span class="article-category-link ds-thread-count" data-thread-key="undefined" data-count-type="comments"></span>
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="-">前端开发技术的发展</h1>
<p>前端开发技术，从狭义的定义来看，是指围绕HTML、JavaScript、CSS这样一套体系的开发技术，它的运行宿主是浏览器。从广义的定义来看，包括了：</p>
<ul>
<li>专门为手持终端设计的类似WML这样的类HTML语言，类似WMLScript这样的类JavaScript语言。</li>
<li>VML和SVG等基于XML的描述图形的语言。</li>
<li>从属于XML体系的XML，XPath，DTD等技术。</li>
<li>用于支撑后端的ASP，JSP，ASP.net，PHP，nodejs等语言或者技术。</li>
<li>被第三方程序打包的一种类似浏览器的宿主环境，比如Adobe AIR和使用HyBird方式的一些开发技术，如PhoneGap（它使用Android中的WebView等技术，让开发人员使用传统Web开发技术来开发本地应用）</li>
<li>Adobe Flash，Flex，Microsoft Silverlight，Java Applet，JavaFx等RIA开发技术。</li>
</ul>
<p>本文从狭义的前端定义出发，探讨一下这方面开发技术的发展过程。
<a id="more"></a>
从前端开发技术的发展来看，大致可以分为以下几个阶段：</p>
<h1 id="-">一. 刀耕火种</h1>
<h2 id="1-">1. 静态页面</h2>
<p>最早期的Web界面基本都是在互联网上使用，人们浏览某些内容，填写几个表单，并且提交。当时的界面以浏览为主，基本都是HTML代码，有时候穿插一些JavaScript，作为客户端校验这样的基础功能。代码的组织比较简单，而且CSS的运用也是比较少的。</p>
<p>最简单的是这样一个文件：</p>
<pre><code>&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;测试一&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;主标题&lt;/h1&gt;
        &lt;p&gt;段落内容&lt;/p&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre><h2 id="2-">2. 带有简单逻辑的界面</h2>
<p>这个界面带有一段JavaScript代码，用于拼接两个输入框中的字符串，并且弹出窗口显示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>	&lt;html&gt;
		<span class="xml"><span class="tag">&lt;<span class="title">head</span>&gt;</span>
			<span class="tag">&lt;<span class="title">title</span>&gt;</span>测试二<span class="tag">&lt;/<span class="title">title</span>&gt;</span>
		<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
		<span class="tag">&lt;<span class="title">body</span>&gt;</span>
			<span class="tag">&lt;<span class="title">input</span> <span class="attribute">id</span>=<span class="value">"firstNameInput"</span> <span class="attribute">type</span>=<span class="value">"text"</span> /&gt;</span> 
			<span class="tag">&lt;<span class="title">input</span> <span class="attribute">id</span>=<span class="value">"lastNameInput"</span> <span class="attribute">type</span>=<span class="value">"text"</span> /&gt;</span> 
			<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"button"</span> <span class="attribute">onclick</span>=<span class="value">"greet()"</span> /&gt;</span>
			<span class="tag">&lt;<span class="title">script</span> <span class="attribute">language</span>=<span class="value">"JavaScript"</span>&gt;</span><span class="javascript">
			<span class="function"><span class="keyword">function</span> <span class="title">greet</span><span class="params">()</span> {</span>
				<span class="keyword">var</span> firstName = document.getElementById(<span class="string">"firstNameInput"</span>).value;
				<span class="keyword">var</span> lastName = document.getElementById(<span class="string">"lastNameInput"</span>).value;
				alert(<span class="string">"Hello, "</span> + firstName + <span class="string">"."</span> + lastName);
			}
			</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span> 
		<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
	<span class="tag">&lt;/<span class="title">html</span>&gt;</span></span>
</pre></td></tr></table></figure>


<h2 id="3-">3. 结合了服务端技术的混合编程</h2>
<p>由于静态界面不能实现保存数据等功能，出现了很多服务端技术，早期的有CGI（Common Gateway Interface，多数用C语言或者Perl实现的），ASP（使用VBScript或者JScript），JSP（使用Java），PHP等等，Python和Ruby等语言也常被用于这类用途。</p>
<p>有了这类技术，在HTML中就可以使用表单的post功能提交数据了，比如：</p>
<pre><code>&lt;form method=&quot;post&quot; action=&quot;username.asp&quot;&gt;
    &lt;p&gt;First Name: &lt;input type=&quot;text&quot; name=&quot;firstName&quot; /&gt;&lt;/p&gt;
    &lt;p&gt;Last Name: &lt;input type=&quot;text&quot; name=&quot;lastName&quot; /&gt;&lt;/p&gt;
    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;
&lt;/form&gt;
</code></pre><p>在这个阶段，由于客户端和服务端的职责未作明确的划分，比如生成一个字符串，可以由前端的JavaScript做，也可以由服务端语言做，所以通常在一个界面里，会有两种语言混杂在一起，用&lt;%和%&gt;标记的部分会在服务端执行，输出结果，甚至经常有把数据库连接的代码跟页面代码混杂在一起的情况，给维护带来较大的不便。</p>
<pre><code>&lt;html&gt;
    &lt;body&gt;
        &lt;p&gt;Hello world!&lt;/p&gt;
        &lt;p&gt;
        &lt;%
            response.write(&quot;Hello world from server!&quot;)
        %&gt;
        &lt;/p&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre><h2 id="4-">4.组件化的萌芽</h2>
<p>这个时代，也逐渐出现了组件化的萌芽。比较常见的有服务端的组件化，比如把某一类服务端功能单独做成片段，然后其他需要的地方来include进来，典型的有：ASP里面数据库连接的地方，把数据源连接的部分写成conn.asp，然后其他每个需要操作数据库的asp文件包含它。</p>
<p>上面所说的是在服务端做的，浏览器端通常有针对JavaScript的，把某一类的Javascript代码写到单独的js文件中，界面根据需要，引用不同的js文件。针对界面的组件方式，通常利用frameset和iframe这两个标签。某一大块有独立功能的界面写到一个html文件，然后在主界面里面把它当作一个frame来载入，一般的B/S系统集成菜单的方式都是这样的。</p>
<p>此外，还出现了一些基于特定浏览器的客户端组件技术，比如IE浏览器的HTC（HTML Component）。这种技术最初是为了对已有的常用元素附加行为的，后来有些场合也用它来实现控件。微软ASP.net的一些版本里，使用这种技术提供了树形列表，日历，选项卡等功能。HTC的优点是允许用户自行扩展HTML标签，可以在自己的命名空间里定义元素，然后，使用HTML，JavaScript和CSS来实现它的布局、行为和观感。这种技术因为是微软的私有技术，所以逐渐变得不那么流行。</p>
<p>Firefox浏览器里面推出过一种叫XUL的技术，也没有流行起来。</p>
<h1 id="-">二. 铁器时代</h1>
<p>这个时代的典型特征是Ajax的出现。</p>
<h2 id="1-ajax">1. AJAX</h2>
<p>AJAX其实是一系列已有技术的组合，早在这个名词出现之前，这些技术的使用就已经比较广泛了，GMail因为恰当地应用了这些技术，获得了很好的用户体验。</p>
<p>由于Ajax的出现，规模更大，效果更好的Web程序逐渐出现，在这些程序中，JavaScript代码的数量迅速增加。出于代码组织的需要，“JavaScript框架”这个概念逐步形成，当时的主流是prototype和mootools，这两者各有千秋，提供了各自方式的面向对象组织思路。</p>
<h2 id="2-javascript-">2. JavaScript基础库</h2>
<p>Prototype框架主要是为JavaScript代码提供了一种组织方式，对一些原生的JavaScript类型提供了一些扩展，比如数组、字符串，又额外提供了一些实用的数据结构，如：枚举，Hash等，除此之外，还对dom操作，事件，表单和Ajax做了一些封装。</p>
<p>Mootools框架的思路跟Prototype很接近，它对JavaScript类型扩展的方式别具一格，所以在这类框架中，经常被称作“最优雅的”对象扩展体系。</p>
<p>从这两个框架的所提供的功能来看，它们的定位是核心库，在使用的时候一般需要配合一些外围的库来完成。</p>
<p>jQuery与这两者有所不同，它着眼于简化DOM相关的代码。
例如：</p>
<ul>
<li>DOM的选择</li>
</ul>
<p>jQuery提供了一系列选择器用于选取界面元素，在其他一些框架中也有类似功能，但是一般没有它的简洁、强大。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>	$(<span class="string">"*"</span>)				<span class="comment">//选取所有元素</span>
	$(<span class="string">"#lastname"</span>)		<span class="comment">//选取id为lastname的元素</span>
	$(<span class="string">".intro"</span>)			<span class="comment">//选取所有class="intro"的元素</span>
	$(<span class="string">"p"</span>)				<span class="comment">//选取所有&amp;lt;p&amp;gt;元素</span>
	$(<span class="string">".intro.demo"</span>)	<span class="comment">//选取所有 class="intro"且class="demo"的元素</span>
</pre></td></tr></table></figure>


<ul>
<li>链式表达式：</li>
</ul>
<p>在jQuery中，可以使用链式表达式来连续操作dom，比如下面这个例子：</p>
<p>如果不使用链式表达式，可能我们需要这么写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>	<span class="keyword">var</span> neat = $(<span class="string">"p.neat"</span>);
	neat.addClass(<span class="string">"ohmy"</span>);
	neat.show(<span class="string">"slow"</span>);
</pre></td></tr></table></figure>


<p>但是有了链式表达式，我们只需要这么一行代码就可以完成这些：</p>
<pre><code>$(&quot;p.neat&quot;).addClass(&quot;ohmy&quot;).show(&quot;slow&quot;);
</code></pre><p>除此之外，jQuery还提供了一些动画方面的特效代码，也有大量的外围库，比如jQuery UI这样的控件库，jQuery mobile这样的移动开发库等等。</p>
<h2 id="3-">3. 模块代码加载方式</h2>
<p>以上这些框架提供了代码的组织能力，但是未能提供代码的动态加载能力。动态加载JavaScript为什么重要呢？因为随着Ajax的普及，jQuery等辅助库的出现，Web上可以做很复杂的功能，因此，单页面应用程序（SPA，Single Page Application）也逐渐多了起来。</p>
<p>单个的界面想要做很多功能，需要写的代码是会比较多的，但是，并非所有的功能都需要在界面加载的时候就全部引入，如果能够在需要的时候才加载那些代码，就把加载的压力分担了，在这个背景下，出现了一些用于动态加载JavaScript的框架，也出现了一些定义这类可被动态加载代码的规范。</p>
<p>在这些框架里，知名度比较高的是RequireJS，它遵循一种称为AMD（Asynchronous Module Definition）的规范。</p>
<p>比如下面这段，定义了一个动态的匿名模块，它依赖math模块</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>	define([<span class="string">"math"</span>], <span class="function"><span class="keyword">function</span><span class="params">(math)</span> {</span>
		<span class="keyword">return</span> {
			addTen : <span class="function"><span class="keyword">function</span><span class="params">(x)</span> {</span>
				<span class="keyword">return</span> math.add(x, <span class="number">10</span>);
			}
		};
	}); 
</pre></td></tr></table></figure>


<p>假设上面的代码存放于adder.js中，当需要使用这个模块的时候，通过如下代码来引入adder：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>	&lt;script src=<span class="string">"require.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
	<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
		<span class="built_in">require</span>([<span class="string">"adder"</span>], <span class="function"><span class="keyword">function</span><span class="params">(adder)</span> {</span>
			<span class="comment">//使用这个adder</span>
		}); 
	</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span>
</pre></td></tr></table></figure>


<p>RequireJS除了提供异步加载方式，也可以使用同步方式加载模块代码。AMD规范除了使用在前端浏览器环境中，也可以运行于nodejs等服务端环境，nodejs的模块就是基于这套规范定义的。（修订，这里弄错了，nodejs是基于类似的CMD规范的）</p>
<h1 id="-">三. 工业革命</h1>
<p>这个时期，随着Web端功能的日益复杂，人们开始考虑这样一些问题：</p>
<ul>
<li>如何更好地模块化开发</li>
<li>业务数据如何组织</li>
<li>界面和业务数据之间通过何种方式进行交互</li>
</ul>
<p>在这种背景下，出现了一些前端MVC、MVP、MVVM框架，我们把这些框架统称为MV*框架。这些框架的出现，都是为了解决上面这些问题，具体的实现思路各有不同，主流的有Backbone，AngularJS，Ember，Spine等等，本文主要选用Backbone和AngularJS来讲述以下场景。</p>
<h2 id="1-">1. 数据模型</h2>
<p>在这些框架里，定义数据模型的方式与以往有些差异，主要在于数据的get和set更加有意义了，比如说，可以把某个实体的get和set绑定到RESTful的服务上，这样，对某个实体的读写可以更新到数据库中。另外一个特点是，它们一般都提供一个事件，用于监控数据的变化，这个机制使得数据绑定成为可能。</p>
<p>在一些框架中，数据模型需要在原生的JavaScript类型上做一层封装，比如Backbone的方式是这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre>	<span class="keyword">var</span> Todo = Backbone.Model.extend({
		<span class="comment">// Default attributes for the todo item.</span>
		defaults : <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
			<span class="keyword">return</span> {
				title : <span class="string">"empty todo..."</span>,
				order : Todos.nextOrder(),
				done : <span class="literal">false</span>
			};
		},

		<span class="comment">// Ensure that each todo created has `title`.</span>
		initialize : <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
			<span class="keyword">if</span> (!<span class="keyword">this</span>.get(<span class="string">"title"</span>)) {
				<span class="keyword">this</span>.set({
					<span class="string">"title"</span> : <span class="keyword">this</span>.defaults().title
				});
			}
		},

		<span class="comment">// Toggle the 'done' state of this todo item.</span>
		toggle : <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
			<span class="keyword">this</span>.save({
				done : !<span class="keyword">this</span>.get(<span class="string">"done"</span>)
			});
		}
	});
</pre></td></tr></table></figure>


<p>上述例子中，defaults方法用于提供模型的默认值，initialize方法用于做一些初始化工作，这两个都是约定的方法，toggle是自定义的，用于保存todo的选中状态。</p>
<p>除了对象，Backbone也支持集合类型，集合类型在定义的时候要通过model属性指定其中的元素类型。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre>	<span class="comment">// The collection of todos is backed by *localStorage* instead of a remote server.</span>
	<span class="keyword">var</span> TodoList = Backbone.Collection.extend({
		<span class="comment">// Reference to this collection's model.</span>
		model : Todo,

		<span class="comment">// Save all of the todo items under the '"todos-backbone"' namespace.</span>
		localStorage : <span class="keyword">new</span> Backbone.LocalStorage(<span class="string">"todos-backbone"</span>),

		<span class="comment">// Filter down the list of all todo items that are finished.</span>
		done : <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
			<span class="keyword">return</span> <span class="keyword">this</span>.filter(<span class="function"><span class="keyword">function</span><span class="params">(todo)</span> {</span>
				<span class="keyword">return</span> todo.get(<span class="string">'done'</span>);
			});
		},

		<span class="comment">// Filter down the list to only todo items that are still not finished.</span>
		remaining : <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
			<span class="keyword">return</span> <span class="keyword">this</span>.without.apply(<span class="keyword">this</span>, <span class="keyword">this</span>.done());
		},

		<span class="comment">// We keep the Todos in sequential order, despite being saved by unordered </span>
		<span class="comment">//GUID in the database. This generates the next order number for new items.</span>
		nextOrder : <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
			<span class="keyword">if</span> (!<span class="keyword">this</span>.length)
				<span class="keyword">return</span> <span class="number">1</span>;
			<span class="keyword">return</span> <span class="keyword">this</span>.last().get(<span class="string">'order'</span>) + <span class="number">1</span>;
		},

		<span class="comment">// Todos are sorted by their original insertion order.</span>
		comparator : <span class="function"><span class="keyword">function</span><span class="params">(todo)</span> {</span>
			<span class="keyword">return</span> todo.get(<span class="string">'order'</span>);
		}
	});
</pre></td></tr></table></figure>


<p>数据模型也可以包含一些方法，比如自身的校验，或者跟后端的通讯、数据的存取等等，在上面两个例子中，也都有体现。</p>
<p>AngularJS的模型定义方式与Backbone不同，可以不需要经过一层封装，直接使用原生的JavaScript简单数据、对象、数组，相对来说比较简便。</p>
<h2 id="2-">2. 控制器</h2>
<p>在Backbone中，是没有独立的控制器的，它的一些控制的职责都放在了视图里，所以其实这是一种MVP（Model View Presentation）模式，而AngularJS有很清晰的控制器层。</p>
<p>还是以这个todo为例，在AngularJS中，会有一些约定的注入，比如$scope，它是控制器、模型和视图之间的桥梁。在控制器定义的时候，将$scope作为参数，然后，就可以在控制器里面为它添加模型的支持。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre>	<span class="function"><span class="keyword">function</span> <span class="title">TodoCtrl</span><span class="params">($scope)</span> {</span>
		$scope.todos = [{
			text : <span class="string">'learn angular'</span>,
			done : <span class="literal">true</span>
		}, {
			text : <span class="string">'build an angular app'</span>,
			done : <span class="literal">false</span>
		}];

		$scope.addTodo = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
			$scope.todos.push({
				text : $scope.todoText,
				done : <span class="literal">false</span>
			});
			$scope.todoText = <span class="string">''</span>;
		};

		$scope.remaining = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
			<span class="keyword">var</span> count = <span class="number">0</span>;
			angular.forEach($scope.todos, <span class="function"><span class="keyword">function</span><span class="params">(todo)</span> {</span>
				count += todo.done ? <span class="number">0</span> : <span class="number">1</span>;
			});
			<span class="keyword">return</span> count;
		};

		$scope.archive = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
			<span class="keyword">var</span> oldTodos = $scope.todos;
			$scope.todos = [];
			angular.forEach(oldTodos, <span class="function"><span class="keyword">function</span><span class="params">(todo)</span> {</span>
				<span class="keyword">if</span> (!todo.done)
					$scope.todos.push(todo);
			});
		};
	}
</pre></td></tr></table></figure>


<p>本例中为$scope添加了todos这个数组，addTodo，remaining和archive三个方法，然后，可以在视图中对他们进行绑定。</p>
<h2 id="3-">3. 视图</h2>
<p>在这些主流的MV*框架中，一般都提供了定义视图的功能。在Backbone中，是这样定义视图的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre></td><td class="code"><pre>	<span class="comment">// The DOM element for a todo item...</span>
	<span class="keyword">var</span> TodoView = Backbone.View.extend({
		<span class="comment">//... is a list tag.</span>
		tagName : <span class="string">"li"</span>,

		<span class="comment">// Cache the template function for a single item.</span>
		template : _.template($(<span class="string">'#item-template'</span>).html()),

		<span class="comment">// The DOM events specific to an item.</span>
		events : {
			<span class="string">"click .toggle"</span> : <span class="string">"toggleDone"</span>,
			<span class="string">"dblclick .view"</span> : <span class="string">"edit"</span>,
			<span class="string">"click a.destroy"</span> : <span class="string">"clear"</span>,
			<span class="string">"keypress .edit"</span> : <span class="string">"updateOnEnter"</span>,
			<span class="string">"blur .edit"</span> : <span class="string">"close"</span>
		},

		<span class="comment">// The TodoView listens for changes to its model, re-rendering. Since there's</span>
		<span class="comment">// a one-to-one correspondence between a **Todo** and a **TodoView** in this</span>
		<span class="comment">// app, we set a direct reference on the model for convenience.</span>
		initialize : <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
			<span class="keyword">this</span>.listenTo(<span class="keyword">this</span>.model, <span class="string">'change'</span>, <span class="keyword">this</span>.render);
			<span class="keyword">this</span>.listenTo(<span class="keyword">this</span>.model, <span class="string">'destroy'</span>, <span class="keyword">this</span>.remove);
		},

		<span class="comment">// Re-render the titles of the todo item.</span>
		render : <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
			<span class="keyword">this</span>.$el.html(<span class="keyword">this</span>.template(<span class="keyword">this</span>.model.toJSON()));
			<span class="keyword">this</span>.$el.toggleClass(<span class="string">'done'</span>, <span class="keyword">this</span>.model.get(<span class="string">'done'</span>));
			<span class="keyword">this</span>.input = <span class="keyword">this</span>.$(<span class="string">'.edit'</span>);
			<span class="keyword">return</span> <span class="keyword">this</span>;
		},

		<span class="comment">//......</span>

		<span class="comment">// Remove the item, destroy the model.</span>
		clear : <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
			<span class="keyword">this</span>.model.destroy();
		}
	});
</pre></td></tr></table></figure>


<p>上面这个例子是一个典型的“部件”视图，它对于界面上的已有元素没有依赖。也有那么一些视图，需要依赖于界面上的已有元素，比如下面这个，它通过el属性，指定了HTML中id为todoapp的元素，并且还在initialize方法中引用了另外一些元素，通常，需要直接放置到界面的顶层试图会采用这种方式，而“部件”视图一般由主视图来创建、布局。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre></td><td class="code"><pre>	<span class="comment">// Our overall **AppView** is the top-level piece of UI.</span>
	<span class="keyword">var</span> AppView = Backbone.View.extend({
		<span class="comment">// Instead of generating a new element, bind to the existing skeleton of</span>
		<span class="comment">// the App already present in the HTML.</span>
		el : $(<span class="string">"#todoapp"</span>),

		<span class="comment">// Our template for the line of statistics at the bottom of the app.</span>
		statsTemplate : _.template($(<span class="string">'#stats-template'</span>).html()),

		<span class="comment">// Delegated events for creating new items, and clearing completed ones.</span>
		events : {
			<span class="string">"keypress #new-todo"</span> : <span class="string">"createOnEnter"</span>,
			<span class="string">"click #clear-completed"</span> : <span class="string">"clearCompleted"</span>,
			<span class="string">"click #toggle-all"</span> : <span class="string">"toggleAllComplete"</span>
		},

		<span class="comment">// At initialization we bind to the relevant events on the `Todos`</span>
		<span class="comment">// collection, when items are added or changed. Kick things off by</span>
		<span class="comment">// loading any preexisting todos that might be saved in *localStorage*.</span>
		initialize : <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
			<span class="keyword">this</span>.input = <span class="keyword">this</span>.$(<span class="string">"#new-todo"</span>);
			<span class="keyword">this</span>.allCheckbox = <span class="keyword">this</span>.$(<span class="string">"#toggle-all"</span>)[<span class="number">0</span>];

			<span class="keyword">this</span>.listenTo(Todos, <span class="string">'add'</span>, <span class="keyword">this</span>.addOne);
			<span class="keyword">this</span>.listenTo(Todos, <span class="string">'reset'</span>, <span class="keyword">this</span>.addAll);
			<span class="keyword">this</span>.listenTo(Todos, <span class="string">'all'</span>, <span class="keyword">this</span>.render);

			<span class="keyword">this</span>.footer = <span class="keyword">this</span>.$(<span class="string">'footer'</span>);
			<span class="keyword">this</span>.main = $(<span class="string">'#main'</span>);

			Todos.fetch();
		},

		<span class="comment">// Re-rendering the App just means refreshing the statistics -- the rest</span>
		<span class="comment">// of the app doesn't change.</span>
		render : <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
			<span class="keyword">var</span> done = Todos.done().length;
			<span class="keyword">var</span> remaining = Todos.remaining().length;

			<span class="keyword">if</span> (Todos.length) {
				<span class="keyword">this</span>.main.show();
				<span class="keyword">this</span>.footer.show();
				<span class="keyword">this</span>.footer.html(<span class="keyword">this</span>.statsTemplate({
					done : done,
					remaining : remaining
				}));
			} <span class="keyword">else</span> {
				<span class="keyword">this</span>.main.hide();
				<span class="keyword">this</span>.footer.hide();
			}

			<span class="keyword">this</span>.allCheckbox.checked = !remaining;
		},

		<span class="comment">//......</span>
	});
</pre></td></tr></table></figure>


<p>对于AngularJS来说，基本不需要有额外的视图定义，它采用的是直接定义在HTML上的方式，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>	&lt;div ng-controller=<span class="string">"TodoCtrl"</span>&gt;
		<span class="xml"><span class="tag">&lt;<span class="title">span</span>&gt;</span>[object Object] of [object Object] remaining<span class="tag">&lt;/<span class="title">span</span>&gt;</span>
		<span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">""</span> <span class="attribute">ng-click</span>=<span class="value">"archive()"</span>&gt;</span>archive<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
		<span class="tag">&lt;<span class="title">ul</span> <span class="attribute">class</span>=<span class="value">"unstyled"</span>&gt;</span>
			<span class="tag">&lt;<span class="title">li</span> <span class="attribute">ng-repeat</span>=<span class="value">"todo in todos"</span>&gt;</span>
				<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"checkbox"</span> <span class="attribute">ng-model</span>=<span class="value">"todo.done"</span>&gt;</span>
				<span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"done-[object Object]"</span>&gt;</span>[object Object]<span class="tag">&lt;/<span class="title">span</span>&gt;</span>
			<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
		<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
		<span class="tag">&lt;<span class="title">form</span> <span class="attribute">ng-submit</span>=<span class="value">"addTodo()"</span>&gt;</span>
			<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">ng-model</span>=<span class="value">"todoText"</span>  <span class="attribute">size</span>=<span class="value">"30"</span>
			<span class="attribute">placeholder</span>=<span class="value">"add new todo here"</span>&gt;</span>
			<span class="tag">&lt;<span class="title">input</span> <span class="attribute">class</span>=<span class="value">"btn-primary"</span> <span class="attribute">type</span>=<span class="value">"submit"</span> <span class="attribute">value</span>=<span class="value">"add"</span>&gt;</span>
		<span class="tag">&lt;/<span class="title">form</span>&gt;</span>
	<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span>
</pre></td></tr></table></figure>


<p>在这个例子中，使用ng-controller注入了一个TodoCtrl的实例，然后，在TodoCtrl的$scope中附加的那些变量和方法都可以直接访问了。注意到其中的ng-repeat部分，它遍历了todos数组，然后使用其中的单个todo对象创建了一些HTML元素，把相应的值填到里面。这种做法和ng-model一样，都创造了双向绑定，即：</p>
<ul>
<li>改变模型可以随时反映到界面上</li>
<li>在界面上做的操作（输入，选择等等）可以实时反映到模型里。</li>
</ul>
<p>而且，这种绑定都会自动忽略其中可能因为空数据而引起的异常情况。</p>
<h2 id="4-">4. 模板</h2>
<p><img src="http://ww3.sinaimg.cn/large/005yyi5Jjw1egkik3qdd4j30ji1al0yz.jpg" alt="images1"></p>
<h2 id="5-">5. 路由</h2>
<p>通常路由是定义在后端的，但是在这类MV*框架的帮助下，路由可以由前端来解析执行。比如下面这个Backbone的路由示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>	<span class="keyword">var</span> Workspace = Backbone.Router.extend({
		routes: {
			<span class="string">"help"</span>:				 <span class="string">"help"</span>,	<span class="comment">// #help</span>
			<span class="string">"search/:query"</span>:		<span class="string">"search"</span>,  <span class="comment">// #search/kiwis</span>
			<span class="string">"search/:query/p:page"</span>: <span class="string">"search"</span>   <span class="comment">// #search/kiwis/p7</span>
		},
		
		help: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
			...
		},
		
		search: <span class="function"><span class="keyword">function</span><span class="params">(query, page)</span> {</span>
			...
		}	
	});
</pre></td></tr></table></figure>


<p>在上述例子中，定义了一些路由的映射关系，那么，在实际访问的时候，如果在地址栏输入&quot;#search/obama/p2&quot;，就会匹配到&quot;search/:query/p:page&quot;这条路由，然后，把&quot;obama&quot;和&quot;2&quot;当作参数，传递给search方法。</p>
<p>AngularJS中定义路由的方式有些区别，它使用一个$routeProvider来提供路由的存取，每一个when表达式配置一条路由信息，otherwise配置默认路由，在配置路由的时候，可以指定一个额外的控制器，用于控制这条路由对应的html界面：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>	app.config([<span class="string">'$routeProvider'</span>,
	<span class="function"><span class="keyword">function</span><span class="params">($routeProvider)</span> {</span>
		$routeProvider.when(<span class="string">'/phones'</span>, {
			templateUrl : <span class="string">'partials/phone-list.html'</span>,
			controller : PhoneListCtrl
		}).when(<span class="string">'/phones/:phoneId'</span>, {
			templateUrl : <span class="string">'partials/phone-detail.html'</span>,
			controller : PhoneDetailCtrl
		}).otherwise({
			redirectTo : <span class="string">'/phones'</span>
		});
	}]); 
</pre></td></tr></table></figure>


<p>注意，在AngularJS中，路由的template并非一个完整的html文件，而是其中的一段，文件的头尾都可以不要，也可以不要那些包含的外部样式和JavaScript文件，这些在主界面中载入就可以了。</p>
<h2 id="6-">6. 自定义标签</h2>
<p>用过XAML或者MXML的人一定会对其中的可扩充标签印象深刻，对于前端开发人员而言，基于标签的组件定义方式一定是优于其他任何方式的，看下面这段HTML：</p>
<pre><code>&lt;div&gt;
    &lt;input type=&quot;text&quot; value=&quot;hello, world&quot;/&gt;
    &lt;button&gt;test&lt;/button&gt;
&lt;/div&gt;
</code></pre><p>即使是刚刚接触这种东西的新手，也能够理解它的意思，并且能够照着做出类似的东西，如果使用传统的面向对象语言去描述界面，效率远远没有这么高，这就是在界面开发领域，声明式编程比命令式编程适合的最重要原因。</p>
<p>但是，HTML的标签是有限的，如果我们需要的功能不在其中，怎么办？在开发过程中，我们可能需要一个选项卡的功能，但是，HTML里面不提供选项卡标签，所以，一般来说，会使用一些li元素和div的组合，加上一些css，来实现选项卡的效果，也有的框架使用JavaScript来完成这些功能。总的来说，这些代码都不够简洁直观。</p>
<p>如果能够有一种技术，能够提供类似这样的方式，该多么好呢？</p>
<pre><code>&lt;tabs&gt;
    &lt;tab name=&quot;Tab 1&quot;&gt;content 1&lt;/tab&gt;
    &lt;tab name=&quot;Tab 2&quot;&gt;content 2&lt;/tab&gt;
&lt;/tabs&gt;
</code></pre><p>回忆一下，我们在章节1.4 组件化的萌芽 里面，提到过一种叫做HTC的技术，这种技术提供了类似的功能，而且使用起来也比较简便，问题是，它属于一种正在消亡的技术，于是我们的目光投向了更为现代的前端世界，AngularJS拯救了我们。</p>
<p>在AngularJS的首页，可以看到这么一个区块“Create Components”，在它的演示代码里，能够看到类似的一段：</p>
<pre><code>&lt;tabs&gt;
    &lt;pane title=&quot;Localization&quot;&gt;
        ...
    &lt;/pane&gt;
    &lt;pane title=&quot;Pluralization&quot;&gt;
        ...
    &lt;/pane&gt;
&lt;/tabs&gt;
</code></pre><p>那么，它是怎么做到的呢？秘密在这里：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td><td class="code"><pre>
angular.module(<span class="string">'components'</span>, []).directive(<span class="string">'tabs'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
	<span class="keyword">return</span> {
		restrict : <span class="string">'E'</span>,
		transclude : <span class="literal">true</span>,
		scope : {},
		controller : <span class="function"><span class="keyword">function</span><span class="params">($scope, $element)</span> {</span>
			<span class="keyword">var</span> panes = $scope.panes = [];

			$scope.select = <span class="function"><span class="keyword">function</span><span class="params">(pane)</span> {</span>
				angular.forEach(panes, <span class="function"><span class="keyword">function</span><span class="params">(pane)</span> {</span>
					pane.selected = <span class="literal">false</span>;
				});
				pane.selected = <span class="literal">true</span>;
			}

			<span class="keyword">this</span>.addPane = <span class="function"><span class="keyword">function</span><span class="params">(pane)</span> {</span>
				<span class="keyword">if</span> (panes.length == <span class="number">0</span>)
					$scope.select(pane);
				panes.push(pane);
			}
		},
		template : <span class="string">'&lt;div class="tabbable"&gt;'</span>
			+ <span class="string">'&lt;ul class="nav nav-tabs"&gt;'</span> 
			+ <span class="string">'&lt;li ng-repeat="pane in panes" ng-class="{active:pane.selected}"&gt;'</span> 
			+ <span class="string">'&lt;a href="" ng-click="select(pane)"&gt;[object Object]&lt;/a&gt;'</span> 
			+ <span class="string">'&lt;/li&gt;'</span> 
			+ <span class="string">'&lt;/ul&gt;'</span> 
			+ <span class="string">'&lt;div class="tab-content" ng-transclude&gt;&lt;/div&gt;'</span> 
			+ <span class="string">'&lt;/div&gt;'</span>,
		replace : <span class="literal">true</span>
	};
}).directive(<span class="string">'pane'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
	<span class="keyword">return</span> {
		<span class="built_in">require</span> : <span class="string">'^tabs'</span>,
		restrict : <span class="string">'E'</span>,
		transclude : <span class="literal">true</span>,
		scope : {
			title : <span class="string">'@'</span>
		},
		link : <span class="function"><span class="keyword">function</span><span class="params">(scope, element, attrs, tabsCtrl)</span> {</span>
			tabsCtrl.addPane(scope);
		},
		template : <span class="string">'&lt;div class="tab-pane" ng-class="{active: selected}" ng-transclude&gt;'</span> + <span class="string">'&lt;/div&gt;'</span>,
		replace : <span class="literal">true</span>
	};
})
</pre></td></tr></table></figure>


<p>这段代码里，定义了tabs和pane两个标签，并且限定了pane标签不能脱离tabs而单独存在，tabs的controller定义了它的行为，两者的template定义了实际生成的html，通过这种方式，开发者可以扩展出自己需要的新元素，对于使用者而言，这不会增加任何额外的负担。</p>
<h1 id="-">四. 一些想说的话</h1>
<h3 id="-extjs">关于ExtJS</h3>
<p>注意到在本文中，并未提及这样一个比较流行的前端框架，主要是因为他自成一系，思路跟其他框架不同，所做的事情，层次介于文中的二和三之间，所以没有单独列出。</p>
<h3 id="-">写作目的</h3>
<p>在我10多年的Web开发生涯中，经历了Web相关技术的各种变革，从2003年开始，接触并使用到了HTC，VML，XMLHTTP等当时比较先进的技术，目睹了网景浏览器的衰落，IE的后来居上，Firefox和Chrome的逆袭，各类RIA技术的风起云涌，对JavaScript的模块化有过持续的思考。未来究竟是什么样子？我说不清楚，只能凭自己的一些认识，把这些年一些比较主流的发展过程总结一下，供有需要了解的朋友们作个参考，错漏在所难免，欢迎大家指教。</p>
<p>个人邮箱：xu.fei@outlook.com<br>新浪微博：<a href="http://weibo.com/sharpmaster" target="_blank">http://weibo.com/sharpmaster</a></p>
<p>原文链接:<a href="http://blog.xufei.gitpress.org/~posts/2013-01-14-%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8F%91%E5%B1%95.md" target="_blank">民工的砖墙</a></p>
<p><img width="100" title="由朱小贱发现" src="https://avatars0.githubusercontent.com/u/4251360?s=100" /></p>

      
    </div>
    <footer class="article-footer">
      
   


  <div class="ds-thread"></div>
<!-- Duoshuo Comment BEGIN -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"suningwiki"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- Duoshuo Comment END -->


  

      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/discover/2014/05/14/fe-moudle/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">前端工程之模块化</div>
    </a>
  
</nav>

  
</article>

</section>
      
        <aside class="pure-u-1-6">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list">
	  
	    <li class="category-list-item"><a class="category-list-link" href="/discover/categories/JavaScript/">JavaScript</a><span class="category-list-count">5</span></li>
	  
	    <li class="category-list-item"><a class="category-list-link" href="/discover/categories/NodeJs/">NodeJs</a><span class="category-list-count">1</span></li>
	  
	    <li class="category-list-item"><a class="category-list-link" href="/discover/categories/前端心得/">前端心得</a><span class="category-list-count">6</span></li>
	  
	    <li class="category-list-item"><a class="category-list-link" href="/discover/categories/前端架构/">前端架构</a><span class="category-list-count">1</span></li>
	  
	    <li class="category-list-item"><a class="category-list-link" href="/discover/categories/移动前端/">移动前端</a><span class="category-list-count">1</span></li>
	  
	  </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/discover/2014/05/20/technologies/">前端开发技术的发展</a>
          </li>
        
          <li>
            <a href="/discover/2014/05/14/fe-moudle/">前端工程之模块化</a>
          </li>
        
          <li>
            <a href="/discover/2014/05/13/exp/">webapp开发实践</a>
          </li>
        
          <li>
            <a href="/discover/2014/05/05/thejavascriptrightway/">The javascript right way</a>
          </li>
        
          <li>
            <a href="/discover/2014/04/03/f2e-pic/">一揽子前端有关图片</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/discover/tags/API/" style="font-size: 10.00px;">API</a><a href="/discover/tags/jquery/" style="font-size: 10.00px;">jquery</a><a href="/discover/tags/mobile/" style="font-size: 10.00px;">mobile</a><a href="/discover/tags/prototype/" style="font-size: 10.00px;">prototype</a><a href="/discover/tags/webApp/" style="font-size: 10.00px;">webApp</a><a href="/discover/tags/教程/" style="font-size: 20.00px;">教程</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/discover/archives/2014/05">五月 2014</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/discover/archives/2014/04">四月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/discover/archives/2014/03">三月 2014</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/discover/archives/2014/02">二月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/discover/archives/2013/12">十二月 2013</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
    <div id="footer-info" class="inner">
      &copy; 2014 发现前端<br>
    </div>
</footer>
  
<script type="text/javascript" src="/discover/js/script.js"></script>
</body>
</html>